{
  "address": "0x0CEBB5ea4fCF7fa5228c4Ae32c26a537904a31B5",
  "abi": [
    {
      "inputs": [],
      "name": "NegativeValueNotAllowed",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "int256",
          "name": "value",
          "type": "int256"
        }
      ],
      "name": "fromInt256",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "val",
              "type": "bytes"
            },
            {
              "internalType": "bool",
              "name": "neg",
              "type": "bool"
            }
          ],
          "internalType": "struct CommonTypes.BigInt",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "fromUint256",
      "outputs": [
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "val",
              "type": "bytes"
            },
            {
              "internalType": "bool",
              "name": "neg",
              "type": "bool"
            }
          ],
          "internalType": "struct CommonTypes.BigInt",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "val",
              "type": "bytes"
            },
            {
              "internalType": "bool",
              "name": "neg",
              "type": "bool"
            }
          ],
          "internalType": "struct CommonTypes.BigInt",
          "name": "bigInt",
          "type": "tuple"
        }
      ],
      "name": "toInt256",
      "outputs": [
        {
          "internalType": "int256",
          "name": "",
          "type": "int256"
        },
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "bytes",
              "name": "val",
              "type": "bytes"
            },
            {
              "internalType": "bool",
              "name": "neg",
              "type": "bool"
            }
          ],
          "internalType": "struct CommonTypes.BigInt",
          "name": "bigInt",
          "type": "tuple"
        }
      ],
      "name": "toUint256",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xb81726fe3cfcc997af5b37d541b32aa6f826c56c631913e50369a24968b1d913",
  "receipt": {
    "to": null,
    "from": "0x6228e24Fd0ad7697585BdC7e1AAea279914D7549",
    "contractAddress": "0x0CEBB5ea4fCF7fa5228c4Ae32c26a537904a31B5",
    "transactionIndex": 0,
    "gasUsed": "54296198",
    "logsBloom": "0xe40042250814420218c0357000160c00482186000000000288a1e2002580450300409000400a02a24080200280018104040674094b048484825000b120ac20009810b002082c10081900000804940480c04134002004301a0a0e280a6a26468000041241832430284628981008100800250208040122ca00601020540842004000c00076c0100829004000000004001308900aa88004c80000503280562800501226816290040201320801400404280a4004e14aa4c000200959c1484000400848b7044220004400a00400800204e000118008000409c231e50041202448e020203781228c4080840188284040008214010800630094001050ca2c80104b210c",
    "blockHash": "0xe8821c9cb4ab5210cc0b8272c6ff0de3d0795c727bc350fa30e2b771194d1cc0",
    "transactionHash": "0xb81726fe3cfcc997af5b37d541b32aa6f826c56c631913e50369a24968b1d913",
    "logs": [],
    "blockNumber": 312349,
    "cumulativeGasUsed": "0",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 2,
  "solcInputHash": "ace9ef673aa915ddbb11c2ca6b8ce85c",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"NegativeValueNotAllowed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"value\",\"type\":\"int256\"}],\"name\":\"fromInt256\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"val\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"neg\",\"type\":\"bool\"}],\"internalType\":\"struct CommonTypes.BigInt\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"fromUint256\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"val\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"neg\",\"type\":\"bool\"}],\"internalType\":\"struct CommonTypes.BigInt\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"val\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"neg\",\"type\":\"bool\"}],\"internalType\":\"struct CommonTypes.BigInt\",\"name\":\"bigInt\",\"type\":\"tuple\"}],\"name\":\"toInt256\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"val\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"neg\",\"type\":\"bool\"}],\"internalType\":\"struct CommonTypes.BigInt\",\"name\":\"bigInt\",\"type\":\"tuple\"}],\"name\":\"toUint256\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/libraries/BigInts.sol\":\"BigIntsClient\"},\"evmVersion\":\"london\",\"libraries\":{\":__CACHE_BREAKER__\":\"0x0000000000000031363833323139313032373532\"},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"details\":{\"constantOptimizer\":true,\"cse\":true,\"deduplicate\":true,\"inliner\":true,\"jumpdestRemover\":true,\"orderLiterals\":true,\"peephole\":true,\"yul\":false},\"runs\":1},\"remappings\":[\":@ensdomains/buffer/=lib/filecoin-solidity/lib/buffer/\",\":@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\":@zondax/solidity-bignumber/=lib/solidity-BigNumber/\",\":ERC4626/=lib/ERC4626/src/\",\":buffer/=lib/buffer/contracts/\",\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":fei-protocol/erc4626/=lib/ERC4626/src/\",\":fevmate/=lib/fevmate/contracts/\",\":filecoin-solidity/=lib/filecoin-solidity/\",\":forge-std/=lib/forge-std/src/\",\":solidity-BigNumber/=lib/solidity-BigNumber/src/\",\":solidity-bignumber/=lib/filecoin-solidity/lib/solidity-bignumber/src/\",\":solidity-cborutils/=lib/solidity-cborutils/contracts/\",\":solidity-cborutils/contracts/=lib/solidity-cborutils/contracts/\",\":solmate/=lib/solmate/src/\"]},\"sources\":{\"contracts/libraries/BigInts.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.17;\\n\\nimport {BigInts, CommonTypes} from \\\"lib/filecoin-solidity/contracts/v0.8/utils/BigInts.sol\\\";\\n\\ninterface IBigInts {\\n\\tfunction toUint256(CommonTypes.BigInt memory bigInt) external view returns (uint256, bool);\\n\\n\\tfunction fromUint256(uint256 value) external view returns (CommonTypes.BigInt memory);\\n\\n\\tfunction toInt256(CommonTypes.BigInt memory bigInt) external view returns (int256, bool);\\n\\n\\tfunction fromInt256(int256 value) external view returns (CommonTypes.BigInt memory);\\n}\\n\\ncontract BigIntsClient is IBigInts {\\n\\tusing BigInts for *;\\n\\n\\tfunction toUint256(CommonTypes.BigInt memory bigInt) external view returns (uint256, bool) {\\n\\t\\treturn bigInt.toUint256();\\n\\t}\\n\\n\\tfunction fromUint256(uint256 value) external view returns (CommonTypes.BigInt memory) {\\n\\t\\treturn value.fromUint256();\\n\\t}\\n\\n\\tfunction toInt256(CommonTypes.BigInt memory bigInt) external view returns (int256, bool) {\\n\\t\\treturn bigInt.toInt256();\\n\\t}\\n\\n\\tfunction fromInt256(int256 value) external view returns (CommonTypes.BigInt memory) {\\n\\t\\treturn value.fromInt256();\\n\\t}\\n}\\n\",\"keccak256\":\"0x490ec194184d1d75d0d779eefca8f5795dd9cb80e7ba4b8b5747fb9eaf48a004\",\"license\":\"AGPL-3.0-only\"},\"lib/filecoin-solidity/contracts/v0.8/types/CommonTypes.sol\":{\"content\":\"/*******************************************************************************\\n *   (c) 2022 Zondax AG\\n *\\n *  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n *  you may not use this file except in compliance with the License.\\n *  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n *  Unless required by applicable law or agreed to in writing, software\\n *  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n *  See the License for the specific language governing permissions and\\n *  limitations under the License.\\n ********************************************************************************/\\n//\\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\\n\\n// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.17;\\n\\n\\n/// @title Filecoin actors' common types for Solidity.\\n/// @author Zondax AG\\nlibrary CommonTypes {\\n    uint constant UniversalReceiverHookMethodNum = 3726118371;\\n\\n    /// @param idx index for the failure in batch\\n    /// @param code failure code\\n    struct FailCode {\\n        uint32 idx;\\n        uint32 code;\\n    }\\n\\n    /// @param success_count total successes in batch\\n    /// @param fail_codes list of failures code and index for each failure in batch\\n    struct BatchReturn {\\n        uint32 success_count;\\n        FailCode[] fail_codes;\\n    }\\n\\n    /// @param type_ asset type\\n    /// @param payload payload corresponding to asset type\\n    struct UniversalReceiverParams {\\n        uint32 type_;\\n        bytes payload;\\n    }\\n\\n    /// @param val contains the actual arbitrary number written as binary\\n    /// @param neg indicates if val is negative or not\\n    struct BigInt {\\n        bytes val;\\n        bool neg;\\n    }\\n\\n    /// @param data filecoin address in bytes format\\n    struct FilAddress {\\n        bytes data;\\n    }\\n\\n    /// @param data cid in bytes format\\n    struct Cid {\\n        bytes data;\\n    }\\n\\n    /// @param data deal proposal label in bytes format (it can be utf8 string or arbitrary bytes string).\\n    /// @param isString indicates if the data is string or raw bytes\\n    struct DealLabel {\\n        bytes data;\\n        bool isString;\\n    }\\n\\n    type FilActorId is uint64;\\n\\n    type ChainEpoch is int64;\\n}\\n\",\"keccak256\":\"0x1819b8e82cf53f0fadc446d064a380979888b97a0004f1e70c9fa1a6f4f13ed9\",\"license\":\"Apache-2.0\"},\"lib/filecoin-solidity/contracts/v0.8/utils/BigInts.sol\":{\"content\":\"/*******************************************************************************\\n *   (c) 2022 Zondax AG\\n *\\n *  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n *  you may not use this file except in compliance with the License.\\n *  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n *  Unless required by applicable law or agreed to in writing, software\\n *  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n *  See the License for the specific language governing permissions and\\n *  limitations under the License.\\n ********************************************************************************/\\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\\n\\n// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.17;\\n\\nimport \\\"lib/solidity-BigNumber/src/BigNumbers.sol\\\";\\n\\nimport \\\"../types/CommonTypes.sol\\\";\\nimport \\\"../utils/Misc.sol\\\";\\n\\n/// @notice This library is a set a functions that allows to handle filecoin addresses conversions and validations\\n/// @author Zondax AG\\nlibrary BigInts {\\n    uint256 constant MAX_UINT = (2 ** 256) - 1;\\n    uint256 constant MAX_INT = ((2 ** 256) / 2) - 1;\\n\\n    error NegativeValueNotAllowed();\\n\\n    /// @notice allow to get a BigInt from a uint256 value\\n    /// @param value uint256 number\\n    /// @return new BigInt\\n    function fromUint256(uint256 value) internal view returns (CommonTypes.BigInt memory) {\\n        BigNumber memory bigNum = BigNumbers.init(value, false);\\n        return CommonTypes.BigInt(bigNum.val, bigNum.neg);\\n    }\\n\\n    /// @notice allow to get a BigInt from a int256 value\\n    /// @param value int256 number\\n    /// @return new BigInt\\n    function fromInt256(int256 value) internal view returns (CommonTypes.BigInt memory) {\\n        uint256 valueAbs = Misc.abs(value);\\n        BigNumber memory bigNum = BigNumbers.init(valueAbs, value < 0);\\n        return CommonTypes.BigInt(bigNum.val, bigNum.neg);\\n    }\\n\\n    /// @notice allow to get a uint256 from a BigInt value.\\n    /// @notice If the value is negative, it will generate an error.\\n    /// @param value BigInt number\\n    /// @return a uint256 value and flog that indicates whether it was possible to convert or not (the value overflows uint256 type)\\n    function toUint256(CommonTypes.BigInt memory value) internal view returns (uint256, bool) {\\n        if (value.neg) {\\n            revert NegativeValueNotAllowed();\\n        }\\n\\n        BigNumber memory max = BigNumbers.init(MAX_UINT, false);\\n        BigNumber memory bigNumValue = BigNumbers.init(value.val, value.neg);\\n        if (BigNumbers.gt(bigNumValue, max)) {\\n            return (0, true);\\n        }\\n\\n        return (uint256(bytes32(bigNumValue.val)), false);\\n    }\\n\\n    /// @notice allow to get a int256 from a BigInt value.\\n    /// @notice If the value is grater than what a int256 can store, it will generate an error.\\n    /// @param value BigInt number\\n    /// @return a int256 value and flog that indicates whether it was possible to convert or not (the value overflows int256 type)\\n    function toInt256(CommonTypes.BigInt memory value) internal view returns (int256, bool) {\\n        BigNumber memory max = BigNumbers.init(MAX_INT, false);\\n        BigNumber memory bigNumValue = BigNumbers.init(value.val, false);\\n        if (BigNumbers.gt(bigNumValue, max)) {\\n            return (0, true);\\n        }\\n\\n        int256 parsedValue = int256(uint256(bytes32(bigNumValue.val)));\\n        return (value.neg ? -1 * parsedValue : parsedValue, false);\\n    }\\n}\\n\",\"keccak256\":\"0xf2c9db71519dd5e0b8550cc9c988e42c545b03f88e12a77ac414db2e1b5eb08b\",\"license\":\"Apache-2.0\"},\"lib/filecoin-solidity/contracts/v0.8/utils/Misc.sol\":{\"content\":\"/*******************************************************************************\\n *   (c) 2022 Zondax AG\\n *\\n *  Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n *  you may not use this file except in compliance with the License.\\n *  You may obtain a copy of the License at\\n *\\n *      http://www.apache.org/licenses/LICENSE-2.0\\n *\\n *  Unless required by applicable law or agreed to in writing, software\\n *  distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n *  See the License for the specific language governing permissions and\\n *  limitations under the License.\\n ********************************************************************************/\\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\\n\\n// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.17;\\n\\nimport \\\"../types/CommonTypes.sol\\\";\\n\\n/// @title Library containing miscellaneous functions used on the project\\n/// @author Zondax AG\\nlibrary Misc {\\n    uint64 constant DAG_CBOR_CODEC = 0x71;\\n    uint64 constant CBOR_CODEC = 0x51;\\n    uint64 constant NONE_CODEC = 0x00;\\n\\n    // Code taken from Openzeppelin repo\\n    // Link: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/0320a718e8e07b1d932f5acb8ad9cec9d9eed99b/contracts/utils/math/SignedMath.sol#L37-L42\\n    /// @notice get the abs from a signed number\\n    /// @param n number to get abs from\\n    /// @return unsigned number\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n\\n    /// @notice validate if an address exists or not\\n    /// @dev read this article for more information https://blog.finxter.com/how-to-find-out-if-an-ethereum-address-is-a-contract/\\n    /// @param addr address to check\\n    /// @return whether the address exists or not\\n    function addressExists(address addr) internal view returns (bool) {\\n        bytes32 codehash;\\n        assembly {\\n            codehash := extcodehash(addr)\\n        }\\n        return codehash != 0x0;\\n    }\\n\\n    /// Returns the data size required by CBOR.writeFixedNumeric\\n    function getPrefixSize(uint256 data_size) internal pure returns (uint256) {\\n        if (data_size <= 23) {\\n            return 1;\\n        } else if (data_size <= 0xFF) {\\n            return 2;\\n        } else if (data_size <= 0xFFFF) {\\n            return 3;\\n        } else if (data_size <= 0xFFFFFFFF) {\\n            return 5;\\n        }\\n        return 9;\\n    }\\n\\n    function getBytesSize(bytes memory value) internal pure returns (uint256) {\\n        return getPrefixSize(value.length) + value.length;\\n    }\\n\\n    function getCidSize(bytes memory value) internal pure returns (uint256) {\\n        return getPrefixSize(2) + value.length;\\n    }\\n\\n    function getFilActorIdSize(CommonTypes.FilActorId value) internal pure returns (uint256) {\\n        uint64 val = CommonTypes.FilActorId.unwrap(value);\\n        return getPrefixSize(uint256(val));\\n    }\\n\\n    function getChainEpochSize(CommonTypes.ChainEpoch value) internal pure returns (uint256) {\\n        int64 val = CommonTypes.ChainEpoch.unwrap(value);\\n        if (val >= 0) {\\n            return getPrefixSize(uint256(uint64(val)));\\n        } else {\\n            return getPrefixSize(uint256(uint64(-1 - val)));\\n        }\\n    }\\n\\n    function getBoolSize() internal pure returns (uint256) {\\n        return getPrefixSize(1);\\n    }\\n}\\n\",\"keccak256\":\"0x97b02c3ab9cb11169b0b1a143b513017c6bf0f2cba2fc4f81a77345b5dfe96b4\",\"license\":\"Apache-2.0\"},\"lib/solidity-BigNumber/src/BigNumbers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n// Definition here allows both the lib and inheriting contracts to use BigNumber directly.\\nstruct BigNumber { \\n    bytes val;\\n    bool neg;\\n    uint bitlen;\\n}\\n\\n/**\\n * @notice BigNumbers library for Solidity.\\n */\\nlibrary BigNumbers {\\n    \\n    /// @notice the value for number 0 of a BigNumber instance.\\n    bytes constant ZERO = hex\\\"0000000000000000000000000000000000000000000000000000000000000000\\\";\\n    /// @notice the value for number 1 of a BigNumber instance.\\n    bytes constant  ONE = hex\\\"0000000000000000000000000000000000000000000000000000000000000001\\\";\\n    /// @notice the value for number 2 of a BigNumber instance.\\n    bytes constant  TWO = hex\\\"0000000000000000000000000000000000000000000000000000000000000002\\\";\\n\\n    // ***************** BEGIN EXPOSED MANAGEMENT FUNCTIONS ******************\\n    /** @notice verify a BN instance\\n     *  @dev checks if the BN is in the correct format. operations should only be carried out on\\n     *       verified BNs, so it is necessary to call this if your function takes an arbitrary BN\\n     *       as input.\\n     *\\n     *  @param bn BigNumber instance\\n     */\\n    function verify(\\n        BigNumber memory bn\\n    ) internal pure {\\n        uint msword; \\n        bytes memory val = bn.val;\\n        assembly {msword := mload(add(val,0x20))} //get msword of result\\n        if(msword==0) require(isZero(bn));\\n        else require((bn.val.length % 32 == 0) && (msword>>((bn.bitlen%256)-1)==1));\\n    }\\n\\n    /** @notice initialize a BN instance\\n     *  @dev wrapper function for _init. initializes from bytes value.\\n     *       Allows passing bitLength of value. This is NOT verified in the internal function. Only use where bitlen is\\n     *       explicitly known; otherwise use the other init function.\\n     *\\n     *  @param val BN value. may be of any size.\\n     *  @param neg neg whether the BN is +/-\\n     *  @param bitlen bit length of output.\\n     *  @return BigNumber instance\\n     */\\n    function init(\\n        bytes memory val, \\n        bool neg, \\n        uint bitlen\\n    ) internal view returns(BigNumber memory){\\n        return _init(val, neg, bitlen);\\n    }\\n    \\n    /** @notice initialize a BN instance\\n     *  @dev wrapper function for _init. initializes from bytes value.\\n     *\\n     *  @param val BN value. may be of any size.\\n     *  @param neg neg whether the BN is +/-\\n     *  @return BigNumber instance\\n     */\\n    function init(\\n        bytes memory val, \\n        bool neg\\n    ) internal view returns(BigNumber memory){\\n        return _init(val, neg, 0);\\n    }\\n\\n    /** @notice initialize a BN instance\\n     *  @dev wrapper function for _init. initializes from uint value (converts to bytes); \\n     *       tf. resulting BN is in the range -2^256-1 ... 2^256-1.\\n     *\\n     *  @param val uint value.\\n     *  @param neg neg whether the BN is +/-\\n     *  @return BigNumber instance\\n     */\\n    function init(\\n        uint val, \\n        bool neg\\n    ) internal view returns(BigNumber memory){\\n        return _init(abi.encodePacked(val), neg, 0);\\n    }\\n    // ***************** END EXPOSED MANAGEMENT FUNCTIONS ******************\\n\\n\\n\\n\\n    // ***************** BEGIN EXPOSED CORE CALCULATION FUNCTIONS ******************\\n    /** @notice BigNumber addition: a + b.\\n      * @dev add: Initially prepare BigNumbers for addition operation; internally calls actual addition/subtraction,\\n      *           depending on inputs.\\n      *           In order to do correct addition or subtraction we have to handle the sign.\\n      *           This function discovers the sign of the result based on the inputs, and calls the correct operation.\\n      *\\n      * @param a first BN\\n      * @param b second BN\\n      * @return r result  - addition of a and b.\\n      */\\n    function add(\\n        BigNumber memory a, \\n        BigNumber memory b\\n    ) internal pure returns(BigNumber memory r) {\\n        if(a.bitlen==0 && b.bitlen==0) return zero();\\n        if(a.bitlen==0) return b;\\n        if(b.bitlen==0) return a;\\n        bytes memory val;\\n        uint bitlen;\\n        int compare = cmp(a,b,false);\\n\\n        if(a.neg || b.neg){\\n            if(a.neg && b.neg){\\n                if(compare>=0) (val, bitlen) = _add(a.val,b.val,a.bitlen);\\n                else (val, bitlen) = _add(b.val,a.val,b.bitlen);\\n                r.neg = true;\\n            }\\n            else {\\n                if(compare==1){\\n                    (val, bitlen) = _sub(a.val,b.val);\\n                    r.neg = a.neg;\\n                }\\n                else if(compare==-1){\\n                    (val, bitlen) = _sub(b.val,a.val);\\n                    r.neg = !a.neg;\\n                }\\n                else return zero();//one pos and one neg, and same value.\\n            }\\n        }\\n        else{\\n            if(compare>=0){ // a>=b\\n                (val, bitlen) = _add(a.val,b.val,a.bitlen);\\n            }\\n            else {\\n                (val, bitlen) = _add(b.val,a.val,b.bitlen);\\n            }\\n            r.neg = false;\\n        }\\n\\n        r.val = val;\\n        r.bitlen = (bitlen);\\n    }\\n\\n    /** @notice BigNumber subtraction: a - b.\\n      * @dev sub: Initially prepare BigNumbers for subtraction operation; internally calls actual addition/subtraction,\\n                  depending on inputs.\\n      *           In order to do correct addition or subtraction we have to handle the sign.\\n      *           This function discovers the sign of the result based on the inputs, and calls the correct operation.\\n      *\\n      * @param a first BN\\n      * @param b second BN\\n      * @return r result - subtraction of a and b.\\n      */  \\n    function sub(\\n        BigNumber memory a, \\n        BigNumber memory b\\n    ) internal pure returns(BigNumber memory r) {\\n        if(a.bitlen==0 && b.bitlen==0) return zero();\\n        bytes memory val;\\n        int compare;\\n        uint bitlen;\\n        compare = cmp(a,b,false);\\n        if(a.neg || b.neg) {\\n            if(a.neg && b.neg){           \\n                if(compare == 1) { \\n                    (val,bitlen) = _sub(a.val,b.val); \\n                    r.neg = true;\\n                }\\n                else if(compare == -1) { \\n\\n                    (val,bitlen) = _sub(b.val,a.val); \\n                    r.neg = false;\\n                }\\n                else return zero();\\n            }\\n            else {\\n                if(compare >= 0) (val,bitlen) = _add(a.val,b.val,a.bitlen);\\n                else (val,bitlen) = _add(b.val,a.val,b.bitlen);\\n                \\n                r.neg = (a.neg) ? true : false;\\n            }\\n        }\\n        else {\\n            if(compare == 1) {\\n                (val,bitlen) = _sub(a.val,b.val);\\n                r.neg = false;\\n             }\\n            else if(compare == -1) { \\n                (val,bitlen) = _sub(b.val,a.val);\\n                r.neg = true;\\n            }\\n            else return zero(); \\n        }\\n        \\n        r.val = val;\\n        r.bitlen = (bitlen);\\n    }\\n\\n    /** @notice BigNumber multiplication: a * b.\\n      * @dev mul: takes two BigNumbers and multiplys them. Order is irrelevant.\\n      *              multiplication achieved using modexp precompile:\\n      *                 (a * b) = ((a + b)**2 - (a - b)**2) / 4\\n      *\\n      * @param a first BN\\n      * @param b second BN\\n      * @return r result - multiplication of a and b.\\n      */\\n    function mul(\\n        BigNumber memory a, \\n        BigNumber memory b\\n    ) internal view returns(BigNumber memory r){\\n            \\n        BigNumber memory lhs = add(a,b);\\n        BigNumber memory fst = modexp(lhs, two(), _powModulus(lhs, 2)); // (a+b)^2\\n        \\n        // no need to do subtraction part of the equation if a == b; if so, it has no effect on final result.\\n        if(!eq(a,b)) {\\n            BigNumber memory rhs = sub(a,b);\\n            BigNumber memory snd = modexp(rhs, two(), _powModulus(rhs, 2)); // (a-b)^2\\n            r = _shr(sub(fst, snd) , 2); // (a * b) = (((a + b)**2 - (a - b)**2) / 4\\n        }\\n        else {\\n            r = _shr(fst, 2); // a==b ? (((a + b)**2 / 4\\n        }\\n    }\\n\\n    /** @notice BigNumber division verification: a * b.\\n      * @dev div: takes three BigNumbers (a,b and result), and verifies that a/b == result.\\n      * Performing BigNumber division on-chain is a significantly expensive operation. As a result, \\n      * we expose the ability to verify the result of a division operation, which is a constant time operation. \\n      *              (a/b = result) == (a = b * result)\\n      *              Integer division only; therefore:\\n      *                verify ((b*result) + (a % (b*result))) == a.\\n      *              eg. 17/7 == 2:\\n      *                verify  (7*2) + (17 % (7*2)) == 17.\\n      * The function returns a bool on successful verification. The require statements will ensure that false can never\\n      *  be returned, however inheriting contracts may also want to put this function inside a require statement.\\n      *  \\n      * @param a first BigNumber\\n      * @param b second BigNumber\\n      * @param r result BigNumber\\n      * @return bool whether or not the operation was verified\\n      */\\n    function divVerify(\\n        BigNumber memory a, \\n        BigNumber memory b, \\n        BigNumber memory r\\n    ) internal view returns(bool) {\\n\\n        // first do zero check.\\n        // if a<b (always zero) and r==zero (input check), return true.\\n        if(cmp(a, b, false) == -1){\\n            require(cmp(zero(), r, false)==0);\\n            return true;\\n        }\\n\\n        // Following zero check:\\n        //if both negative: result positive\\n        //if one negative: result negative\\n        //if neither negative: result positive\\n        bool positiveResult = ( a.neg && b.neg ) || (!a.neg && !b.neg);\\n        require(positiveResult ? !r.neg : r.neg);\\n        \\n        // require denominator to not be zero.\\n        require(!(cmp(b,zero(),true)==0));\\n        \\n        // division result check assumes inputs are positive.\\n        // we have already checked for result sign so this is safe.\\n        bool[3] memory negs = [a.neg, b.neg, r.neg];\\n        a.neg = false;\\n        b.neg = false;\\n        r.neg = false;\\n\\n        // do multiplication (b * r)\\n        BigNumber memory fst = mul(b,r);\\n        // check if we already have 'a' (ie. no remainder after division). if so, no mod necessary, and return true.\\n        if(cmp(fst,a,true)==0) return true;\\n        //a mod (b*r)\\n        BigNumber memory snd = modexp(a,one(),fst); \\n        // ((b*r) + a % (b*r)) == a\\n        require(cmp(add(fst,snd),a,true)==0); \\n\\n        a.neg = negs[0];\\n        b.neg = negs[1];\\n        r.neg = negs[2];\\n\\n        return true;\\n    }\\n\\n    /** @notice BigNumber exponentiation: a ^ b.\\n      * @dev pow: takes a BigNumber and a uint (a,e), and calculates a^e.\\n      * modexp precompile is used to achieve a^e; for this is work, we need to work out the minimum modulus value \\n      * such that the modulus passed to modexp is not used. the result of a^e can never be more than size bitlen(a) * e.\\n      * \\n      * @param a BigNumber\\n      * @param e exponent\\n      * @return r result BigNumber\\n      */\\n    function pow(\\n        BigNumber memory a, \\n        uint e\\n    ) internal view returns(BigNumber memory){\\n        return modexp(a, init(e, false), _powModulus(a, e));\\n    }\\n\\n    /** @notice BigNumber modulus: a % n.\\n      * @dev mod: takes a BigNumber and modulus BigNumber (a,n), and calculates a % n.\\n      * modexp precompile is used to achieve a % n; an exponent of value '1' is passed.\\n      * @param a BigNumber\\n      * @param n modulus BigNumber\\n      * @return r result BigNumber\\n      */\\n    function mod(\\n        BigNumber memory a, \\n        BigNumber memory n\\n    ) internal view returns(BigNumber memory){\\n      return modexp(a,one(),n);\\n    }\\n\\n    /** @notice BigNumber modular exponentiation: a^e mod n.\\n      * @dev modexp: takes base, exponent, and modulus, internally computes base^exponent % modulus using the precompile at address 0x5, and creates new BigNumber.\\n      *              this function is overloaded: it assumes the exponent is positive. if not, the other method is used, whereby the inverse of the base is also passed.\\n      *\\n      * @param a base BigNumber\\n      * @param e exponent BigNumber\\n      * @param n modulus BigNumber\\n      * @return result BigNumber\\n      */    \\n    function modexp(\\n        BigNumber memory a, \\n        BigNumber memory e, \\n        BigNumber memory n\\n    ) internal view returns(BigNumber memory) {\\n        //if exponent is negative, other method with this same name should be used.\\n        //if modulus is negative or zero, we cannot perform the operation.\\n        require(  e.neg==false\\n                && n.neg==false\\n                && !isZero(n.val));\\n\\n        bytes memory _result = _modexp(a.val,e.val,n.val);\\n        //get bitlen of result (TODO: optimise. we know bitlen is in the same byte as the modulus bitlen byte)\\n        uint bitlen = bitLength(_result);\\n        \\n        // if result is 0, immediately return.\\n        if(bitlen == 0) return zero();\\n        // if base is negative AND exponent is odd, base^exp is negative, and tf. result is negative;\\n        // in that case we make the result positive by adding the modulus.\\n        if(a.neg && isOdd(e)) return add(BigNumber(_result, true, bitlen), n);\\n        // in any other case we return the positive result.\\n        return BigNumber(_result, false, bitlen);\\n    }\\n\\n    /** @notice BigNumber modular exponentiation with negative base: inv(a)==a_inv && a_inv^e mod n.\\n    /** @dev modexp: takes base, base inverse, exponent, and modulus, asserts inverse(base)==base inverse, \\n      *              internally computes base_inverse^exponent % modulus and creates new BigNumber.\\n      *              this function is overloaded: it assumes the exponent is negative. \\n      *              if not, the other method is used, where the inverse of the base is not passed.\\n      *\\n      * @param a base BigNumber\\n      * @param ai base inverse BigNumber\\n      * @param e exponent BigNumber\\n      * @param a modulus\\n      * @return BigNumber memory result.\\n      */ \\n    function modexp(\\n        BigNumber memory a, \\n        BigNumber memory ai, \\n        BigNumber memory e, \\n        BigNumber memory n) \\n    internal view returns(BigNumber memory) {\\n        // base^-exp = (base^-1)^exp\\n        require(!a.neg && e.neg);\\n\\n        //if modulus is negative or zero, we cannot perform the operation.\\n        require(!n.neg && !isZero(n.val));\\n\\n        //base_inverse == inverse(base, modulus)\\n        require(modinvVerify(a, n, ai)); \\n            \\n        bytes memory _result = _modexp(ai.val,e.val,n.val);\\n        //get bitlen of result (TODO: optimise. we know bitlen is in the same byte as the modulus bitlen byte)\\n        uint bitlen = bitLength(_result);\\n\\n        // if result is 0, immediately return.\\n        if(bitlen == 0) return zero();\\n        // if base_inverse is negative AND exponent is odd, base_inverse^exp is negative, and tf. result is negative;\\n        // in that case we make the result positive by adding the modulus.\\n        if(ai.neg && isOdd(e)) return add(BigNumber(_result, true, bitlen), n);\\n        // in any other case we return the positive result.\\n        return BigNumber(_result, false, bitlen);\\n    }\\n \\n    /** @notice modular multiplication: (a*b) % n.\\n      * @dev modmul: Takes BigNumbers for a, b, and modulus, and computes (a*b) % modulus\\n      *              We call mul for the two input values, before calling modexp, passing exponent as 1.\\n      *              Sign is taken care of in sub-functions.\\n      *\\n      * @param a BigNumber\\n      * @param b BigNumber\\n      * @param n Modulus BigNumber\\n      * @return result BigNumber\\n      */\\n    function modmul(\\n        BigNumber memory a, \\n        BigNumber memory b, \\n        BigNumber memory n) internal view returns(BigNumber memory) {       \\n        return mod(mul(a,b), n);       \\n    }\\n\\n    /** @notice modular inverse verification: Verifies that (a*r) % n == 1.\\n      * @dev modinvVerify: Takes BigNumbers for base, modulus, and result, verifies (base*result)%modulus==1, and returns result.\\n      *              Similar to division, it's far cheaper to verify an inverse operation on-chain than it is to calculate it, so we allow the user to pass their own result.\\n      *\\n      * @param a base BigNumber\\n      * @param n modulus BigNumber\\n      * @param r result BigNumber\\n      * @return boolean result\\n      */\\n    function modinvVerify(\\n        BigNumber memory a, \\n        BigNumber memory n, \\n        BigNumber memory r\\n    ) internal view returns(bool) {\\n        require(!a.neg && !n.neg); //assert positivity of inputs.\\n        /*\\n         * the following proves:\\n         * - user result passed is correct for values base and modulus\\n         * - modular inverse exists for values base and modulus.\\n         * otherwise it fails.\\n         */        \\n        require(cmp(modmul(a, r, n),one(),true)==0);\\n        \\n        return true;\\n    }\\n    // ***************** END EXPOSED CORE CALCULATION FUNCTIONS ******************\\n\\n\\n\\n\\n    // ***************** START EXPOSED HELPER FUNCTIONS ******************\\n    /** @notice BigNumber odd number check\\n      * @dev isOdd: returns 1 if BigNumber value is an odd number and 0 otherwise.\\n      *              \\n      * @param a BigNumber\\n      * @return r Boolean result\\n      */  \\n    function isOdd(\\n        BigNumber memory a\\n    ) internal pure returns(bool r){\\n        assembly{\\n            let a_ptr := add(mload(a), mload(mload(a))) // go to least significant word\\n            r := mod(mload(a_ptr),2)                      // mod it with 2 (returns 0 or 1) \\n        }\\n    }\\n\\n    /** @notice BigNumber comparison\\n      * @dev cmp: Compares BigNumbers a and b. 'signed' parameter indiciates whether to consider the sign of the inputs.\\n      *           'trigger' is used to decide this - \\n      *              if both negative, invert the result; \\n      *              if both positive (or signed==false), trigger has no effect;\\n      *              if differing signs, we return immediately based on input.\\n      *           returns -1 on a<b, 0 on a==b, 1 on a>b.\\n      *           \\n      * @param a BigNumber\\n      * @param b BigNumber\\n      * @param signed whether to consider sign of inputs\\n      * @return int result\\n      */\\n    function cmp(\\n        BigNumber memory a, \\n        BigNumber memory b, \\n        bool signed\\n    ) internal pure returns(int){\\n        int trigger = 1;\\n        if(signed){\\n            if(a.neg && b.neg) trigger = -1;\\n            else if(a.neg==false && b.neg==true) return 1;\\n            else if(a.neg==true && b.neg==false) return -1;\\n        }\\n\\n        if(a.bitlen>b.bitlen) return    trigger;   // 1*trigger\\n        if(b.bitlen>a.bitlen) return -1*trigger;\\n\\n        uint a_ptr;\\n        uint b_ptr;\\n        uint a_word;\\n        uint b_word;\\n\\n        uint len = a.val.length; //bitlen is same so no need to check length.\\n\\n        assembly{\\n            a_ptr := add(mload(a),0x20) \\n            b_ptr := add(mload(b),0x20)\\n        }\\n\\n        for(uint i=0; i<len;i+=32){\\n            assembly{\\n                a_word := mload(add(a_ptr,i))\\n                b_word := mload(add(b_ptr,i))\\n            }\\n\\n            if(a_word>b_word) return    trigger; // 1*trigger\\n            if(b_word>a_word) return -1*trigger; \\n\\n        }\\n\\n        return 0; //same value.\\n    }\\n\\n    /** @notice BigNumber equality\\n      * @dev eq: returns true if a==b. sign always considered.\\n      *           \\n      * @param a BigNumber\\n      * @param b BigNumber\\n      * @return boolean result\\n      */\\n    function eq(\\n        BigNumber memory a, \\n        BigNumber memory b\\n    ) internal pure returns(bool){\\n        int result = cmp(a, b, true);\\n        return (result==0) ? true : false;\\n    }\\n\\n    /** @notice BigNumber greater than\\n      * @dev eq: returns true if a>b. sign always considered.\\n      *           \\n      * @param a BigNumber\\n      * @param b BigNumber\\n      * @return boolean result\\n      */\\n    function gt(\\n        BigNumber memory a, \\n        BigNumber memory b\\n    ) internal pure returns(bool){\\n        int result = cmp(a, b, true);\\n        return (result==1) ? true : false;\\n    }\\n\\n    /** @notice BigNumber greater than or equal to\\n      * @dev eq: returns true if a>=b. sign always considered.\\n      *           \\n      * @param a BigNumber\\n      * @param b BigNumber\\n      * @return boolean result\\n      */\\n    function gte(\\n        BigNumber memory a, \\n        BigNumber memory b\\n    ) internal pure returns(bool){\\n        int result = cmp(a, b, true);\\n        return (result==1 || result==0) ? true : false;\\n    }\\n\\n    /** @notice BigNumber less than\\n      * @dev eq: returns true if a<b. sign always considered.\\n      *           \\n      * @param a BigNumber\\n      * @param b BigNumber\\n      * @return boolean result\\n      */\\n    function lt(\\n        BigNumber memory a, \\n        BigNumber memory b\\n    ) internal pure returns(bool){\\n        int result = cmp(a, b, true);\\n        return (result==-1) ? true : false;\\n    }\\n\\n    /** @notice BigNumber less than or equal o\\n      * @dev eq: returns true if a<=b. sign always considered.\\n      *           \\n      * @param a BigNumber\\n      * @param b BigNumber\\n      * @return boolean result\\n      */\\n    function lte(\\n        BigNumber memory a, \\n        BigNumber memory b\\n    ) internal pure returns(bool){\\n        int result = cmp(a, b, true);\\n        return (result==-1 || result==0) ? true : false;\\n    }\\n\\n    /** @notice right shift BigNumber value\\n      * @dev shr: right shift BigNumber a by 'bits' bits.\\n             copies input value to new memory location before shift and calls _shr function after. \\n      * @param a BigNumber value to shift\\n      * @param bits amount of bits to shift by\\n      * @return result BigNumber\\n      */\\n    function shr(\\n        BigNumber memory a, \\n        uint bits\\n    ) internal view returns(BigNumber memory){\\n        require(!a.neg);\\n        return _shr(a, bits);\\n    }\\n\\n    /** @notice right shift BigNumber memory 'dividend' by 'bits' bits.\\n      * @dev _shr: Shifts input value in-place, ie. does not create new memory. shr function does this.\\n      * right shift does not necessarily have to copy into a new memory location. where the user wishes the modify\\n      * the existing value they have in place, they can use this.  \\n      * @param bn value to shift\\n      * @param bits amount of bits to shift by\\n      * @return r result\\n      */\\n    function _shr(BigNumber memory bn, uint bits) internal view returns(BigNumber memory){\\n        uint length;\\n        assembly { length := mload(mload(bn)) }\\n\\n        // if bits is >= the bitlength of the value the result is always 0\\n        if(bits >= bn.bitlen) return BigNumber(ZERO,false,0); \\n        \\n        // set bitlen initially as we will be potentially modifying 'bits'\\n        bn.bitlen = bn.bitlen-(bits);\\n\\n        // handle shifts greater than 256:\\n        // if bits is greater than 256 we can simply remove any trailing words, by altering the BN length. \\n        // we also update 'bits' so that it is now in the range 0..256.\\n        assembly {\\n            if or(gt(bits, 0x100), eq(bits, 0x100)) {\\n                length := sub(length, mul(div(bits, 0x100), 0x20))\\n                mstore(mload(bn), length)\\n                bits := mod(bits, 0x100)\\n            }\\n\\n            // if bits is multiple of 8 (byte size), we can simply use identity precompile for cheap memcopy.\\n            // otherwise we shift each word, starting at the least signifcant word, one-by-one using the mask technique.\\n            // TODO it is possible to do this without the last two operations, see SHL identity copy.\\n            let bn_val_ptr := mload(bn)\\n            switch eq(mod(bits, 8), 0)\\n              case 1 {  \\n                  let bytes_shift := div(bits, 8)\\n                  let in          := mload(bn)\\n                  let inlength    := mload(in)\\n                  let insize      := add(inlength, 0x20)\\n                  let out         := add(in,     bytes_shift)\\n                  let outsize     := sub(insize, bytes_shift)\\n                  let success     := staticcall(450, 0x4, in, insize, out, insize)\\n                  mstore8(add(out, 0x1f), 0) // maintain our BN layout following identity call:\\n                  mstore(in, inlength)         // set current length byte to 0, and reset old length.\\n              }\\n              default {\\n                  let mask\\n                  let lsw\\n                  let mask_shift := sub(0x100, bits)\\n                  let lsw_ptr := add(bn_val_ptr, length)   \\n                  for { let i := length } eq(eq(i,0),0) { i := sub(i, 0x20) } { // for(int i=max_length; i!=0; i-=32)\\n                      switch eq(i,0x20)                                         // if i==32:\\n                          case 1 { mask := 0 }                                  //    - handles lsword: no mask needed.\\n                          default { mask := mload(sub(lsw_ptr,0x20)) }          //    - else get mask (previous word)\\n                      lsw := shr(bits, mload(lsw_ptr))                          // right shift current by bits\\n                      mask := shl(mask_shift, mask)                             // left shift next significant word by mask_shift\\n                      mstore(lsw_ptr, or(lsw,mask))                             // store OR'd mask and shifted bits in-place\\n                      lsw_ptr := sub(lsw_ptr, 0x20)                             // point to next bits.\\n                  }\\n              }\\n\\n            // The following removes the leading word containing all zeroes in the result should it exist, \\n            // as well as updating lengths and pointers as necessary.\\n            let msw_ptr := add(bn_val_ptr,0x20)\\n            switch eq(mload(msw_ptr), 0) \\n                case 1 {\\n                   mstore(msw_ptr, sub(mload(bn_val_ptr), 0x20)) // store new length in new position\\n                   mstore(bn, msw_ptr)                           // update pointer from bn\\n                }\\n                default {}\\n        }\\n    \\n\\n        return bn;\\n    }\\n\\n    /** @notice left shift BigNumber value\\n      * @dev shr: left shift BigNumber a by 'bits' bits.\\n                  ensures the value is not negative before calling the private function.\\n      * @param a BigNumber value to shift\\n      * @param bits amount of bits to shift by\\n      * @return result BigNumber\\n      */\\n    function shl(\\n        BigNumber memory a, \\n        uint bits\\n    ) internal view returns(BigNumber memory){\\n        require(!a.neg);\\n        return _shl(a, bits);\\n    }\\n\\n    /** @notice sha3 hash a BigNumber.\\n      * @dev hash: takes a BigNumber and performs sha3 hash on it.\\n      *            we hash each BigNumber WITHOUT it's first word - first word is a pointer to the start of the bytes value,\\n      *            and so is different for each struct.\\n      *             \\n      * @param a BigNumber\\n      * @return h bytes32 hash.\\n      */\\n    function hash(\\n        BigNumber memory a\\n    ) internal pure returns(bytes32 h) {\\n        //amount of words to hash = all words of the value and three extra words: neg, bitlen & value length.     \\n        assembly {\\n            h := keccak256( add(a,0x20), add (mload(mload(a)), 0x60 ) ) \\n        }\\n    }\\n\\n    /** @notice BigNumber full zero check\\n      * @dev isZero: checks if the BigNumber is in the default zero format for BNs (ie. the result from zero()).\\n      *             \\n      * @param a BigNumber\\n      * @return boolean result.\\n      */\\n    function isZero(\\n        BigNumber memory a\\n    ) internal pure returns(bool) {\\n        return isZero(a.val) && a.val.length==0x20 && !a.neg && a.bitlen == 0;\\n    }\\n\\n\\n    /** @notice bytes zero check\\n      * @dev isZero: checks if input bytes value resolves to zero.\\n      *             \\n      * @param a bytes value\\n      * @return boolean result.\\n      */\\n    function isZero(\\n        bytes memory a\\n    ) internal pure returns(bool) {\\n        uint msword;\\n        uint msword_ptr;\\n        assembly {\\n            msword_ptr := add(a,0x20)\\n        }\\n        for(uint i=0; i<a.length; i+=32) {\\n            assembly { msword := mload(msword_ptr) } // get msword of input\\n            if(msword > 0) return false;\\n            assembly { msword_ptr := add(msword_ptr, 0x20) }\\n        }\\n        return true;\\n\\n    }\\n\\n    /** @notice BigNumber value bit length\\n      * @dev bitLength: returns BigNumber value bit length- ie. log2 (most significant bit of value)\\n      *             \\n      * @param a BigNumber\\n      * @return uint bit length result.\\n      */\\n    function bitLength(\\n        BigNumber memory a\\n    ) internal pure returns(uint){\\n        return bitLength(a.val);\\n    }\\n\\n    /** @notice bytes bit length\\n      * @dev bitLength: returns bytes bit length- ie. log2 (most significant bit of value)\\n      *             \\n      * @param a bytes value\\n      * @return r uint bit length result.\\n      */\\n    function bitLength(\\n        bytes memory a\\n    ) internal pure returns(uint r){\\n        if(isZero(a)) return 0;\\n        uint msword; \\n        assembly {\\n            msword := mload(add(a,0x20))               // get msword of input\\n        }\\n        r = bitLength(msword);                         // get bitlen of msword, add to size of remaining words.\\n        assembly {                                           \\n            r := add(r, mul(sub(mload(a), 0x20) , 8))  // res += (val.length-32)*8;  \\n        }\\n    }\\n\\n    /** @notice uint bit length\\n        @dev bitLength: get the bit length of a uint input - ie. log2 (most significant bit of 256 bit value (one EVM word))\\n      *                       credit: Tjaden Hess @ ethereum.stackexchange             \\n      * @param a uint value\\n      * @return r uint bit length result.\\n      */\\n    function bitLength(\\n        uint a\\n    ) internal pure returns (uint r){\\n        assembly {\\n            switch eq(a, 0)\\n            case 1 {\\n                r := 0\\n            }\\n            default {\\n                let arg := a\\n                a := sub(a,1)\\n                a := or(a, div(a, 0x02))\\n                a := or(a, div(a, 0x04))\\n                a := or(a, div(a, 0x10))\\n                a := or(a, div(a, 0x100))\\n                a := or(a, div(a, 0x10000))\\n                a := or(a, div(a, 0x100000000))\\n                a := or(a, div(a, 0x10000000000000000))\\n                a := or(a, div(a, 0x100000000000000000000000000000000))\\n                a := add(a, 1)\\n                let m := mload(0x40)\\n                mstore(m,           0xf8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd)\\n                mstore(add(m,0x20), 0xf5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe)\\n                mstore(add(m,0x40), 0xf6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a8272523616)\\n                mstore(add(m,0x60), 0xc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff)\\n                mstore(add(m,0x80), 0xf7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e)\\n                mstore(add(m,0xa0), 0xe39ed557db96902cd38ed14fad815115c786af479b7e83247363534337271707)\\n                mstore(add(m,0xc0), 0xc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d2362422606)\\n                mstore(add(m,0xe0), 0x753a6d1b65325d0c552a4d1345224105391a310b29122104190a110309020100)\\n                mstore(0x40, add(m, 0x100))\\n                let magic := 0x818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff\\n                let shift := 0x100000000000000000000000000000000000000000000000000000000000000\\n                let _a := div(mul(a, magic), shift)\\n                r := div(mload(add(m,sub(255,_a))), shift)\\n                r := add(r, mul(256, gt(arg, 0x8000000000000000000000000000000000000000000000000000000000000000)))\\n                // where a is a power of two, result needs to be incremented. we use the power of two trick here: if(arg & arg-1 == 0) ++r;\\n                if eq(and(arg, sub(arg, 1)), 0) {\\n                    r := add(r, 1) \\n                }\\n            }\\n        }\\n    }\\n\\n    /** @notice BigNumber zero value\\n        @dev zero: returns zero encoded as a BigNumber\\n      * @return zero encoded as BigNumber\\n      */\\n    function zero(\\n    ) internal pure returns(BigNumber memory) {\\n        return BigNumber(ZERO, false, 0);\\n    }\\n\\n    /** @notice BigNumber one value\\n        @dev one: returns one encoded as a BigNumber\\n      * @return one encoded as BigNumber\\n      */\\n    function one(\\n    ) internal pure returns(BigNumber memory) {\\n        return BigNumber(ONE, false, 1);\\n    }\\n\\n    /** @notice BigNumber two value\\n        @dev two: returns two encoded as a BigNumber\\n      * @return two encoded as BigNumber\\n      */\\n    function two(\\n    ) internal pure returns(BigNumber memory) {\\n        return BigNumber(TWO, false, 2);\\n    }\\n    // ***************** END EXPOSED HELPER FUNCTIONS ******************\\n\\n\\n\\n\\n\\n    // ***************** START PRIVATE MANAGEMENT FUNCTIONS ******************\\n    /** @notice Create a new BigNumber.\\n        @dev init: overloading allows caller to obtionally pass bitlen where it is known - as it is cheaper to do off-chain and verify on-chain. \\n      *            we assert input is in data structure as defined above, and that bitlen, if passed, is correct.\\n      *            'copy' parameter indicates whether or not to copy the contents of val to a new location in memory (for example where you pass \\n      *            the contents of another variable's value in)\\n      * @param val bytes - bignum value.\\n      * @param neg bool - sign of value\\n      * @param bitlen uint - bit length of value\\n      * @return r BigNumber initialized value.\\n      */\\n    function _init(\\n        bytes memory val, \\n        bool neg, \\n        uint bitlen\\n    ) private view returns(BigNumber memory r){ \\n        // use identity at location 0x4 for cheap memcpy.\\n        // grab contents of val, load starting from memory end, update memory end pointer.\\n        assembly {\\n            let data := add(val, 0x20)\\n            let length := mload(val)\\n            let out\\n            let freemem := msize()\\n            switch eq(mod(length, 0x20), 0)                       // if(val.length % 32 == 0)\\n                case 1 {\\n                    out     := add(freemem, 0x20)                 // freememory location + length word\\n                    mstore(freemem, length)                       // set new length \\n                }\\n                default { \\n                    let offset  := sub(0x20, mod(length, 0x20))   // offset: 32 - (length % 32)\\n                    out     := add(add(freemem, offset), 0x20)    // freememory location + offset + length word\\n                    mstore(freemem, add(length, offset))          // set new length \\n                }\\n            pop(staticcall(450, 0x4, data, length, out, length))  // copy into 'out' memory location\\n            mstore(0x40, add(freemem, add(mload(freemem), 0x20))) // update the free memory pointer\\n            \\n            // handle leading zero words. assume freemem is pointer to bytes value\\n            let bn_length := mload(freemem)\\n            for { } eq ( eq(bn_length, 0x20), 0) { } {            // for(; length!=32; length-=32)\\n             switch eq(mload(add(freemem, 0x20)),0)               // if(msword==0):\\n                    case 1 { freemem := add(freemem, 0x20) }      //     update length pointer\\n                    default { break }                             // else: loop termination. non-zero word found\\n                bn_length := sub(bn_length,0x20)                          \\n            } \\n            mstore(freemem, bn_length)                             \\n\\n            mstore(r, freemem)                                    // store new bytes value in r\\n            mstore(add(r, 0x20), neg)                             // store neg value in r\\n        }\\n\\n        r.bitlen = bitlen == 0 ? bitLength(r.val) : bitlen;\\n    }\\n    // ***************** END PRIVATE MANAGEMENT FUNCTIONS ******************\\n\\n\\n\\n\\n\\n    // ***************** START PRIVATE CORE CALCULATION FUNCTIONS ******************\\n    /** @notice takes two BigNumber memory values and the bitlen of the max value, and adds them.\\n      * @dev _add: This function is private and only callable from add: therefore the values may be of different sizes,\\n      *            in any order of size, and of different signs (handled in add).\\n      *            As values may be of different sizes, inputs are considered starting from the least significant \\n      *            words, working back. \\n      *            The function calculates the new bitlen (basically if bitlens are the same for max and min, \\n      *            max_bitlen++) and returns a new BigNumber memory value.\\n      *\\n      * @param max bytes -  biggest value  (determined from add)\\n      * @param min bytes -  smallest value (determined from add)\\n      * @param max_bitlen uint - bit length of max value.\\n      * @return bytes result - max + min.\\n      * @return uint - bit length of result.\\n      */\\n    function _add(\\n        bytes memory max, \\n        bytes memory min, \\n        uint max_bitlen\\n    ) private pure returns (bytes memory, uint) {\\n        bytes memory result;\\n        assembly {\\n\\n            let result_start := msize()                                       // Get the highest available block of memory\\n            let carry := 0\\n            let uint_max := sub(0,1)\\n\\n            let max_ptr := add(max, mload(max))\\n            let min_ptr := add(min, mload(min))                               // point to last word of each byte array.\\n\\n            let result_ptr := add(add(result_start,0x20), mload(max))         // set result_ptr end.\\n\\n            for { let i := mload(max) } eq(eq(i,0),0) { i := sub(i, 0x20) } { // for(int i=max_length; i!=0; i-=32)\\n                let max_val := mload(max_ptr)                                 // get next word for 'max'\\n                switch gt(i,sub(mload(max),mload(min)))                       // if(i>(max_length-min_length)). while \\n                                                                              // 'min' words are still available.\\n                    case 1{ \\n                        let min_val := mload(min_ptr)                         //      get next word for 'min'\\n                        mstore(result_ptr, add(add(max_val,min_val),carry))   //      result_word = max_word+min_word+carry\\n                        switch gt(max_val, sub(uint_max,sub(min_val,carry)))  //      this switch block finds whether or\\n                                                                              //      not to set the carry bit for the\\n                                                                              //      next iteration.\\n                            case 1  { carry := 1 }\\n                            default {\\n                                switch and(eq(max_val,uint_max),or(gt(carry,0), gt(min_val,0)))\\n                                case 1 { carry := 1 }\\n                                default{ carry := 0 }\\n                            }\\n                            \\n                        min_ptr := sub(min_ptr,0x20)                       //       point to next 'min' word\\n                    }\\n                    default{                                               // else: remainder after 'min' words are complete.\\n                        mstore(result_ptr, add(max_val,carry))             //       result_word = max_word+carry\\n                        \\n                        switch and( eq(uint_max,max_val), eq(carry,1) )    //       this switch block finds whether or \\n                                                                           //       not to set the carry bit for the \\n                                                                           //       next iteration.\\n                            case 1  { carry := 1 }\\n                            default { carry := 0 }\\n                    }\\n                result_ptr := sub(result_ptr,0x20)                         // point to next 'result' word\\n                max_ptr := sub(max_ptr,0x20)                               // point to next 'max' word\\n            }\\n\\n            switch eq(carry,0) \\n                case 1{ result_start := add(result_start,0x20) }           // if carry is 0, increment result_start, ie.\\n                                                                           // length word for result is now one word \\n                                                                           // position ahead.\\n                default { mstore(result_ptr, 1) }                          // else if carry is 1, store 1; overflow has\\n                                                                           // occured, so length word remains in the \\n                                                                           // same position.\\n\\n            result := result_start                                         // point 'result' bytes value to the correct\\n                                                                           // address in memory.\\n            mstore(result,add(mload(max),mul(0x20,carry)))                 // store length of result. we are finished \\n                                                                           // with the byte array.\\n            \\n            mstore(0x40, add(result,add(mload(result),0x20)))              // Update freemem pointer to point to new \\n                                                                           // end of memory.\\n\\n            // we now calculate the result's bit length.\\n            // with addition, if we assume that some a is at least equal to some b, then the resulting bit length will\\n            // be a's bit length or (a's bit length)+1, depending on carry bit.this is cheaper than calling bitLength.\\n            let msword := mload(add(result,0x20))                             // get most significant word of result\\n            // if(msword==1 || msword>>(max_bitlen % 256)==1):\\n            if or( eq(msword, 1), eq(shr(mod(max_bitlen,256),msword),1) ) {\\n                    max_bitlen := add(max_bitlen, 1)                          // if msword's bit length is 1 greater \\n                                                                              // than max_bitlen, OR overflow occured,\\n                                                                              // new bitlen is max_bitlen+1.\\n                }\\n        }\\n        \\n\\n        return (result, max_bitlen);\\n    }\\n\\n    /** @notice takes two BigNumber memory values and subtracts them.\\n      * @dev _sub: This function is private and only callable from add: therefore the values may be of different sizes, \\n      *            in any order of size, and of different signs (handled in add).\\n      *            As values may be of different sizes, inputs are considered starting from the least significant words,\\n      *            working back. \\n      *            The function calculates the new bitlen (basically if bitlens are the same for max and min, \\n      *            max_bitlen++) and returns a new BigNumber memory value.\\n      *\\n      * @param max bytes -  biggest value  (determined from add)\\n      * @param min bytes -  smallest value (determined from add)\\n      * @return bytes result - max + min.\\n      * @return uint - bit length of result.\\n      */\\n    function _sub(\\n        bytes memory max, \\n        bytes memory min\\n    ) internal pure returns (bytes memory, uint) {\\n        bytes memory result;\\n        uint carry = 0;\\n        uint uint_max = type(uint256).max;\\n        assembly {\\n                \\n            let result_start := msize()                                     // Get the highest available block of \\n                                                                            // memory\\n        \\n            let max_len := mload(max)\\n            let min_len := mload(min)                                       // load lengths of inputs\\n            \\n            let len_diff := sub(max_len,min_len)                            // get differences in lengths.\\n            \\n            let max_ptr := add(max, max_len)\\n            let min_ptr := add(min, min_len)                                // go to end of arrays\\n            let result_ptr := add(result_start, max_len)                    // point to least significant result \\n                                                                            // word.\\n            let memory_end := add(result_ptr,0x20)                          // save memory_end to update free memory\\n                                                                            // pointer at the end.\\n            \\n            for { let i := max_len } eq(eq(i,0),0) { i := sub(i, 0x20) } {  // for(int i=max_length; i!=0; i-=32)\\n                let max_val := mload(max_ptr)                               // get next word for 'max'\\n                switch gt(i,len_diff)                                       // if(i>(max_length-min_length)). while\\n                                                                            // 'min' words are still available.\\n                    case 1{ \\n                        let min_val := mload(min_ptr)                       //  get next word for 'min'\\n        \\n                        mstore(result_ptr, sub(sub(max_val,min_val),carry)) //  result_word = (max_word-min_word)-carry\\n                    \\n                        switch or(lt(max_val, add(min_val,carry)), \\n                               and(eq(min_val,uint_max), eq(carry,1)))      //  this switch block finds whether or \\n                                                                            //  not to set the carry bit for the next iteration.\\n                            case 1  { carry := 1 }\\n                            default { carry := 0 }\\n                            \\n                        min_ptr := sub(min_ptr,0x20)                        //  point to next 'result' word\\n                    }\\n                    default {                                               // else: remainder after 'min' words are complete.\\n\\n                        mstore(result_ptr, sub(max_val,carry))              //      result_word = max_word-carry\\n                    \\n                        switch and( eq(max_val,0), eq(carry,1) )            //      this switch block finds whether or \\n                                                                            //      not to set the carry bit for the \\n                                                                            //      next iteration.\\n                            case 1  { carry := 1 }\\n                            default { carry := 0 }\\n\\n                    }\\n                result_ptr := sub(result_ptr,0x20)                          // point to next 'result' word\\n                max_ptr    := sub(max_ptr,0x20)                             // point to next 'max' word\\n            }      \\n\\n            //the following code removes any leading words containing all zeroes in the result.\\n            result_ptr := add(result_ptr,0x20)                                                 \\n\\n            // for(result_ptr+=32;; result==0; result_ptr+=32)\\n            for { }   eq(mload(result_ptr), 0) { result_ptr := add(result_ptr,0x20) } { \\n               result_start := add(result_start, 0x20)                      // push up the start pointer for the result\\n               max_len := sub(max_len,0x20)                                 // subtract a word (32 bytes) from the \\n                                                                            // result length.\\n            } \\n\\n            result := result_start                                          // point 'result' bytes value to \\n                                                                            // the correct address in memory\\n            \\n            mstore(result,max_len)                                          // store length of result. we \\n                                                                            // are finished with the byte array.\\n            \\n            mstore(0x40, memory_end)                                        // Update freemem pointer.\\n        }\\n\\n        uint new_bitlen = bitLength(result);                                // calculate the result's \\n                                                                            // bit length.\\n        \\n        return (result, new_bitlen);\\n    }\\n\\n    /** @notice gets the modulus value necessary for calculating exponetiation.\\n      * @dev _powModulus: we must pass the minimum modulus value which would return JUST the a^b part of the calculation\\n      *       in modexp. the rationale here is:\\n      *       if 'a' has n bits, then a^e has at most n*e bits.\\n      *       using this modulus in exponetiation will result in simply a^e.\\n      *       therefore the value may be many words long.\\n      *       This is done by:\\n      *         - storing total modulus byte length\\n      *         - storing first word of modulus with correct bit set\\n      *         - updating the free memory pointer to come after total length.\\n      *\\n      * @param a BigNumber base\\n      * @param e uint exponent\\n      * @return BigNumber modulus result\\n      */\\n    function _powModulus(\\n        BigNumber memory a, \\n        uint e\\n    ) private pure returns(BigNumber memory){\\n        bytes memory _modulus = ZERO;\\n        uint mod_index;\\n\\n        assembly {\\n            mod_index := mul(mload(add(a, 0x40)), e)               // a.bitlen * e is the max bitlength of result\\n            let first_word_modulus := shl(mod(mod_index, 256), 1)  // set bit in first modulus word.\\n            mstore(_modulus, mul(add(div(mod_index,256),1),0x20))  // store length of modulus\\n            mstore(add(_modulus,0x20), first_word_modulus)         // set first modulus word\\n            mstore(0x40, add(_modulus, add(mload(_modulus),0x20))) // update freemem pointer to be modulus index\\n                                                                   // + length\\n        }\\n\\n        //create modulus BigNumber memory for modexp function\\n        return BigNumber(_modulus, false, mod_index); \\n    }\\n\\n    /** @notice Modular Exponentiation: Takes bytes values for base, exp, mod and calls precompile for (base^exp)%^mod\\n      * @dev modexp: Wrapper for built-in modexp (contract 0x5) as described here: \\n      *              https://github.com/ethereum/EIPs/pull/198\\n      *\\n      * @param _b bytes base\\n      * @param _e bytes base_inverse \\n      * @param _m bytes exponent\\n      * @param r bytes result.\\n      */\\n    function _modexp(\\n        bytes memory _b, \\n        bytes memory _e, \\n        bytes memory _m\\n    ) private view returns(bytes memory r) {\\n        assembly {\\n            \\n            let bl := mload(_b)\\n            let el := mload(_e)\\n            let ml := mload(_m)\\n            \\n            \\n            let freemem := mload(0x40) // Free memory pointer is always stored at 0x40\\n            \\n            \\n            mstore(freemem, bl)         // arg[0] = base.length @ +0\\n            \\n            mstore(add(freemem,32), el) // arg[1] = exp.length @ +32\\n            \\n            mstore(add(freemem,64), ml) // arg[2] = mod.length @ +64\\n            \\n            // arg[3] = base.bits @ + 96\\n            // Use identity built-in (contract 0x4) as a cheap memcpy\\n            let success := staticcall(450, 0x4, add(_b,32), bl, add(freemem,96), bl)\\n            \\n            // arg[4] = exp.bits @ +96+base.length\\n            let size := add(96, bl)\\n            success := staticcall(450, 0x4, add(_e,32), el, add(freemem,size), el)\\n            \\n            // arg[5] = mod.bits @ +96+base.length+exp.length\\n            size := add(size,el)\\n            success := staticcall(450, 0x4, add(_m,32), ml, add(freemem,size), ml)\\n            \\n            switch success case 0 { invalid() } //fail where we haven't enough gas to make the call\\n\\n            // Total size of input = 96+base.length+exp.length+mod.length\\n            size := add(size,ml)\\n            // Invoke contract 0x5, put return value right after mod.length, @ +96\\n            success := staticcall(sub(gas(), 1350), 0x5, freemem, size, add(freemem, 0x60), ml)\\n\\n            switch success case 0 { invalid() } //fail where we haven't enough gas to make the call\\n\\n            let length := ml\\n            let msword_ptr := add(freemem, 0x60)\\n\\n            ///the following code removes any leading words containing all zeroes in the result.\\n            for { } eq ( eq(length, 0x20), 0) { } {                   // for(; length!=32; length-=32)\\n                switch eq(mload(msword_ptr),0)                        // if(msword==0):\\n                    case 1 { msword_ptr := add(msword_ptr, 0x20) }    //     update length pointer\\n                    default { break }                                 // else: loop termination. non-zero word found\\n                length := sub(length,0x20)                          \\n            } \\n            r := sub(msword_ptr,0x20)\\n            mstore(r, length)\\n            \\n            // point to the location of the return value (length, bits)\\n            //assuming mod length is multiple of 32, return value is already in the right format.\\n            mstore(0x40, add(add(96, freemem),ml)) //deallocate freemem pointer\\n        }        \\n    }\\n    // ***************** END PRIVATE CORE CALCULATION FUNCTIONS ******************\\n\\n\\n\\n\\n\\n    // ***************** START PRIVATE HELPER FUNCTIONS ******************\\n    /** @notice left shift BigNumber memory 'dividend' by 'value' bits.\\n      * @param bn value to shift\\n      * @param bits amount of bits to shift by\\n      * @return r result\\n      */\\n    function _shl(\\n        BigNumber memory bn, \\n        uint bits\\n    ) private view returns(BigNumber memory r) {\\n        if(bits==0 || bn.bitlen==0) return bn;\\n        \\n        // we start by creating an empty bytes array of the size of the output, based on 'bits'.\\n        // for that we must get the amount of extra words needed for the output.\\n        uint length = bn.val.length;\\n        // position of bitlen in most significnat word\\n        uint bit_position = ((bn.bitlen-1) % 256) + 1;\\n        // total extra words. we check if the bits remainder will add one more word.\\n        uint extra_words = (bits / 256) + ( (bits % 256) >= (256 - bit_position) ? 1 : 0);\\n        // length of output\\n        uint total_length = length + (extra_words * 0x20);\\n\\n        r.bitlen = bn.bitlen+(bits);\\n        r.neg = bn.neg;\\n        bits %= 256;\\n\\n        \\n        bytes memory bn_shift;\\n        uint bn_shift_ptr;\\n        // the following efficiently creates an empty byte array of size 'total_length'\\n        assembly {\\n            let freemem_ptr := mload(0x40)                // get pointer to free memory\\n            mstore(freemem_ptr, total_length)             // store bytes length\\n            let mem_end := add(freemem_ptr, total_length) // end of memory\\n            mstore(mem_end, 0)                            // store 0 at memory end\\n            bn_shift := freemem_ptr                       // set pointer to bytes\\n            bn_shift_ptr := add(bn_shift, 0x20)           // get bn_shift pointer\\n            mstore(0x40, add(mem_end, 0x20))              // update freemem pointer\\n        }\\n\\n        // use identity for cheap copy if bits is multiple of 8.\\n        if(bits % 8 == 0) {\\n            // calculate the position of the first byte in the result.\\n            uint bytes_pos = ((256-(((bn.bitlen-1)+bits) % 256))-1) / 8;\\n            uint insize = (bn.bitlen / 8) + ((bn.bitlen % 8 != 0) ? 1 : 0);\\n            assembly {\\n              let in          := add(add(mload(bn), 0x20), div(sub(256, bit_position), 8))\\n              let out         := add(bn_shift_ptr, bytes_pos)\\n              let success     := staticcall(450, 0x4, in, insize, out, length)\\n            }\\n            r.val = bn_shift;\\n            return r;\\n        }\\n\\n\\n        uint mask;\\n        uint mask_shift = 0x100-bits;\\n        uint msw;\\n        uint msw_ptr;\\n\\n       assembly {\\n           msw_ptr := add(mload(bn), 0x20)   \\n       }\\n        \\n       // handle first word before loop if the shift adds any extra words.\\n       // the loop would handle it if the bit shift doesn't wrap into the next word, \\n       // so we check only for that condition.\\n       if((bit_position+bits) > 256){\\n           assembly {\\n              msw := mload(msw_ptr)\\n              mstore(bn_shift_ptr, shr(mask_shift, msw))\\n              bn_shift_ptr := add(bn_shift_ptr, 0x20)\\n           }\\n       }\\n        \\n       // as a result of creating the empty array we just have to operate on the words in the original bn.\\n       for(uint i=bn.val.length; i!=0; i-=0x20){                  // for each word:\\n           assembly {\\n               msw := mload(msw_ptr)                              // get most significant word\\n               switch eq(i,0x20)                                  // if i==32:\\n                   case 1 { mask := 0 }                           // handles msword: no mask needed.\\n                   default { mask := mload(add(msw_ptr,0x20)) }   // else get mask (next word)\\n               msw := shl(bits, msw)                              // left shift current msw by 'bits'\\n               mask := shr(mask_shift, mask)                      // right shift next significant word by mask_shift\\n               mstore(bn_shift_ptr, or(msw,mask))                 // store OR'd mask and shifted bits in-place\\n               msw_ptr := add(msw_ptr, 0x20)\\n               bn_shift_ptr := add(bn_shift_ptr, 0x20)\\n           }\\n       }\\n\\n       r.val = bn_shift;\\n    }\\n    // ***************** END PRIVATE HELPER FUNCTIONS ******************\\n}\\n\",\"keccak256\":\"0x581b5e7b7700a01eeec9ac00825ddb81753cfea182c9211e733eaf883584f7de\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50610b7d806100206000396000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c80631fcf986d146100515780632f7dbc9b1461007b57806383becb8e1461009b578063a2bd3644146100ae575b600080fd5b61006461005f36600461094a565b6100c1565b604051610072929190610994565b60405180910390f35b61008e6100893660046109c0565b6100d6565b6040516100729190610a6b565b6100646100a936600461094a565b6100ed565b61008e6100bc3660046109c0565b6100f9565b6000806100cd8361010a565b91509150915091565b6100de610786565b6100e782610187565b92915050565b6000806100cd836101d0565b610101610786565b6100e78261024e565b60008060006101216001600160ff1b036000610287565b90506000610131855160006102c1565b905061013d81836102d5565b1561015057506000946001945092505050565b6000815161015d90610a86565b9050602086015161016e578061017a565b61017a81600019610ae1565b9660009650945050505050565b61018f610786565b600061019a83610300565b905060006101ab8260008612610287565b9050604051604080820190528082518152602001826020015115159052949350505050565b6000808260200151156101f6576040516341820e7560e11b815260040160405180910390fd5b60006102056000196000610287565b90506000610218855186602001516102c1565b905061022481836102d5565b1561023757506000946001945092505050565b805161024290610a86565b95600095509350505050565b610256610786565b6000610263836000610287565b90506040516040808201905280825181526020018260200151151590529392505050565b61028f61079e565b6102ba836040516020016102a39190610b1f565b604051602081830303815290604052836000610317565b9392505050565b6102c961079e565b6102ba83836000610317565b6000806102e4848460016103ce565b9050806001146102f55760006102f8565b60015b949350505050565b60008082121561031357816000036100e7565b5090565b61031f61079e565b602084018451600059601f8316156001811461034d57601f8416602090810380860184528301019250610357565b6020820192508382525b508282848660046101c2fa506020815101810160405280515b6020811461039e5760006020830151146001811461038e575061039e565b60208301925050601f1901610370565b815284525050506020810183905281156103b857816103c2565b6103c2815161050e565b60408201529392505050565b60006001821561044757846020015180156103ea575083602001515b156103f85750600019610447565b84602001511580156104105750836020015115156001145b1561041f5760019150506102ba565b84602001511515600114801561043757508360200151155b15610447576000199150506102ba565b83604001518560400151111561045e5790506102ba565b8460400151846040015111156104825761047a81600019610ae1565b9150506102ba565b600080808080895151905060208a510194506020895101935060005b818110156104fd57808601519350808501519250828411156104c957869750505050505050506102ba565b838311156104eb576104dd87600019610ae1565b9750505050505050506102ba565b6104f6602082610b34565b905061049e565b5060009a9950505050505050505050565b60006105198261054c565b1561052657506000919050565b60006020830151905061053881610595565b915060086020845103028201915050919050565b60008060208301815b845181101561058a5781519250821561057357506000949350505050565b6020918201916105839082610b34565b9050610555565b506001949350505050565b600081156001811461077b57600160801b600160401b600160201b620100006101006010600460026000198b019081041790810417908104179081041790810417908104179081041790810417600101926040517ff8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd81527ff5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe60208201527ff6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a827252361660408201527fc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff60608201527ff7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e60808201527fe39ed557db96902cd38ed14fad815115c786af479b7e8324736353433727170760a08201527fc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d236242260660c08201527f753a6d1b65325d0c552a4d1345224105391a310b29122104190a11030902010060e082015261010081016040527e818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff600160f81b8082880204818160ff0385015104600160ff1b86116101000201965060001985018516610771576001870196505b5050505050610780565b600091505b50919050565b60405160408082019052606081526000602082015290565b604051806060016040528060608152602001600015158152602001600081525090565b601f01601f191690565b634e487b7160e01b600052604160045260246000fd5b6107ea826107c1565b81018181106001600160401b0382111715610807576108076107cb565b6040525050565b600061081d6000604051905090565b905061082982826107e1565b919050565b60006001600160401b03821115610847576108476107cb565b610850826107c1565b60200192915050565b82818337506000910152565b60006108786108738461082e565b61080e565b90508281526020810184848401111561089357610893600080fd5b61089e848285610859565b509392505050565b600082601f8301126108ba576108ba600080fd5b81356102f8848260208601610865565b8015155b81146108d957600080fd5b50565b80356100e7816108ca565b6000604082840312156108fc576108fc600080fd5b610906604061080e565b905081356001600160401b0381111561092157610921600080fd5b61092d848285016108a6565b825250602061093e848483016108dc565b60208301525092915050565b60006020828403121561095f5761095f600080fd5b81356001600160401b0381111561097857610978600080fd5b6102f8848285016108e7565b805b82525050565b801515610986565b604081016109a28285610984565b6102ba602083018461098c565b806108ce565b80356100e7816109af565b6000602082840312156109d5576109d5600080fd5b60006102f884846109b5565b60005b838110156109fc5780820151838201526020016109e4565b50506000910152565b6000610a15826000815192915050565b808452602084019350610a2c8185602086016109e1565b610a35816107c1565b9093019392505050565b60006040830182518482038552610a568282610a05565b915050602083015161089e602086018261098c565b602080825281016102ba8184610a3f565b60006100e7825190565b6000610a96826000815192915050565b60208301610aa381610a7c565b92506020821015610ac457610abf600019836020036008021b90565b831692505b5050919050565b634e487b7160e01b600052601160045260246000fd5b8181028060008312600160ff1b85141615610afe57610afe610acb565b8282058414831517610b1257610b12610acb565b5092915050565b80610986565b6000610b2b8284610b19565b50602001919050565b808201808211156100e7576100e7610acb56fea26469706673582212200a77b3c3723bdbd7ff8142d6d45bc9aeb801fa3f4fb2e8a9e58fd2c9c8f05e4d64736f6c63430008110033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061004c5760003560e01c80631fcf986d146100515780632f7dbc9b1461007b57806383becb8e1461009b578063a2bd3644146100ae575b600080fd5b61006461005f36600461094a565b6100c1565b604051610072929190610994565b60405180910390f35b61008e6100893660046109c0565b6100d6565b6040516100729190610a6b565b6100646100a936600461094a565b6100ed565b61008e6100bc3660046109c0565b6100f9565b6000806100cd8361010a565b91509150915091565b6100de610786565b6100e782610187565b92915050565b6000806100cd836101d0565b610101610786565b6100e78261024e565b60008060006101216001600160ff1b036000610287565b90506000610131855160006102c1565b905061013d81836102d5565b1561015057506000946001945092505050565b6000815161015d90610a86565b9050602086015161016e578061017a565b61017a81600019610ae1565b9660009650945050505050565b61018f610786565b600061019a83610300565b905060006101ab8260008612610287565b9050604051604080820190528082518152602001826020015115159052949350505050565b6000808260200151156101f6576040516341820e7560e11b815260040160405180910390fd5b60006102056000196000610287565b90506000610218855186602001516102c1565b905061022481836102d5565b1561023757506000946001945092505050565b805161024290610a86565b95600095509350505050565b610256610786565b6000610263836000610287565b90506040516040808201905280825181526020018260200151151590529392505050565b61028f61079e565b6102ba836040516020016102a39190610b1f565b604051602081830303815290604052836000610317565b9392505050565b6102c961079e565b6102ba83836000610317565b6000806102e4848460016103ce565b9050806001146102f55760006102f8565b60015b949350505050565b60008082121561031357816000036100e7565b5090565b61031f61079e565b602084018451600059601f8316156001811461034d57601f8416602090810380860184528301019250610357565b6020820192508382525b508282848660046101c2fa506020815101810160405280515b6020811461039e5760006020830151146001811461038e575061039e565b60208301925050601f1901610370565b815284525050506020810183905281156103b857816103c2565b6103c2815161050e565b60408201529392505050565b60006001821561044757846020015180156103ea575083602001515b156103f85750600019610447565b84602001511580156104105750836020015115156001145b1561041f5760019150506102ba565b84602001511515600114801561043757508360200151155b15610447576000199150506102ba565b83604001518560400151111561045e5790506102ba565b8460400151846040015111156104825761047a81600019610ae1565b9150506102ba565b600080808080895151905060208a510194506020895101935060005b818110156104fd57808601519350808501519250828411156104c957869750505050505050506102ba565b838311156104eb576104dd87600019610ae1565b9750505050505050506102ba565b6104f6602082610b34565b905061049e565b5060009a9950505050505050505050565b60006105198261054c565b1561052657506000919050565b60006020830151905061053881610595565b915060086020845103028201915050919050565b60008060208301815b845181101561058a5781519250821561057357506000949350505050565b6020918201916105839082610b34565b9050610555565b506001949350505050565b600081156001811461077b57600160801b600160401b600160201b620100006101006010600460026000198b019081041790810417908104179081041790810417908104179081041790810417600101926040517ff8f9cbfae6cc78fbefe7cdc3a1793dfcf4f0e8bbd8cec470b6a28a7a5a3e1efd81527ff5ecf1b3e9debc68e1d9cfabc5997135bfb7a7a3938b7b606b5b4b3f2f1f0ffe60208201527ff6e4ed9ff2d6b458eadcdf97bd91692de2d4da8fd2d0ac50c6ae9a827252361660408201527fc8c0b887b0a8a4489c948c7f847c6125746c645c544c444038302820181008ff60608201527ff7cae577eec2a03cf3bad76fb589591debb2dd67e0aa9834bea6925f6a4a2e0e60808201527fe39ed557db96902cd38ed14fad815115c786af479b7e8324736353433727170760a08201527fc976c13bb96e881cb166a933a55e490d9d56952b8d4e801485467d236242260660c08201527f753a6d1b65325d0c552a4d1345224105391a310b29122104190a11030902010060e082015261010081016040527e818283848586878898a8b8c8d8e8f929395969799a9b9d9e9faaeb6bedeeff600160f81b8082880204818160ff0385015104600160ff1b86116101000201965060001985018516610771576001870196505b5050505050610780565b600091505b50919050565b60405160408082019052606081526000602082015290565b604051806060016040528060608152602001600015158152602001600081525090565b601f01601f191690565b634e487b7160e01b600052604160045260246000fd5b6107ea826107c1565b81018181106001600160401b0382111715610807576108076107cb565b6040525050565b600061081d6000604051905090565b905061082982826107e1565b919050565b60006001600160401b03821115610847576108476107cb565b610850826107c1565b60200192915050565b82818337506000910152565b60006108786108738461082e565b61080e565b90508281526020810184848401111561089357610893600080fd5b61089e848285610859565b509392505050565b600082601f8301126108ba576108ba600080fd5b81356102f8848260208601610865565b8015155b81146108d957600080fd5b50565b80356100e7816108ca565b6000604082840312156108fc576108fc600080fd5b610906604061080e565b905081356001600160401b0381111561092157610921600080fd5b61092d848285016108a6565b825250602061093e848483016108dc565b60208301525092915050565b60006020828403121561095f5761095f600080fd5b81356001600160401b0381111561097857610978600080fd5b6102f8848285016108e7565b805b82525050565b801515610986565b604081016109a28285610984565b6102ba602083018461098c565b806108ce565b80356100e7816109af565b6000602082840312156109d5576109d5600080fd5b60006102f884846109b5565b60005b838110156109fc5780820151838201526020016109e4565b50506000910152565b6000610a15826000815192915050565b808452602084019350610a2c8185602086016109e1565b610a35816107c1565b9093019392505050565b60006040830182518482038552610a568282610a05565b915050602083015161089e602086018261098c565b602080825281016102ba8184610a3f565b60006100e7825190565b6000610a96826000815192915050565b60208301610aa381610a7c565b92506020821015610ac457610abf600019836020036008021b90565b831692505b5050919050565b634e487b7160e01b600052601160045260246000fd5b8181028060008312600160ff1b85141615610afe57610afe610acb565b8282058414831517610b1257610b12610acb565b5092915050565b80610986565b6000610b2b8284610b19565b50602001919050565b808201808211156100e7576100e7610acb56fea26469706673582212200a77b3c3723bdbd7ff8142d6d45bc9aeb801fa3f4fb2e8a9e58fd2c9c8f05e4d64736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}